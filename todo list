import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // Allowed package for date/time formatting

// --- 1. Model Definition (Data Structure) ---
class Task {
  final String id;
  final String title;
  bool isCompleted;
  final DateTime? scheduledTime; // New: Optional scheduled time for the task

  Task({
    required this.id,
    required this.title,
    this.isCompleted = false,
    this.scheduledTime, // Initialize scheduledTime
  });
}

// --- 2. State Management (Business Logic) ---
// TaskModel holds the data and logic, extending ChangeNotifier.
class TaskModel extends ChangeNotifier {
  List<Task> _tasks = <Task>[];

  // Getter to provide a copy of the tasks list (best practice)
  List<Task> get tasks => <Task>[..._tasks];

  // New: Getter for the count of completed tasks
  int get completedTaskCount => _tasks.where((Task task) => task.isCompleted).length;

  // New: Getter for the total number of tasks
  int get totalTaskCount => _tasks.length;

  // New: Getter to check if all tasks are completed
  bool get areAllTasksCompleted => totalTaskCount > 0 && completedTaskCount == totalTaskCount;

  void addTask(String title, DateTime? scheduledTime) {
    if (title.isNotEmpty) {
      _tasks.add(Task(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        title: title,
        isCompleted: false,
        scheduledTime: scheduledTime, // Pass scheduledTime to the task
      ));
      // Notify listeners (UI widgets) that the data has changed.
      notifyListeners();
    }
  }

  void toggleTaskCompletion(String id) {
    final int taskIndex = _tasks.indexWhere((Task task) => task.id == id);
    if (taskIndex != -1) {
      _tasks[taskIndex].isCompleted = !_tasks[taskIndex].isCompleted;
      notifyListeners();
    }
  }

  void removeTask(String id) {
    _tasks.removeWhere((Task task) => task.id == id);
    notifyListeners();
  }
}

// --- 3. Main Application Setup ---
void main() {
  // We wrap the entire app in a ChangeNotifierProvider.
  // This makes the single instance of TaskModel available to all descendant widgets.
  runApp(
    ChangeNotifierProvider<TaskModel>(
      create: (BuildContext context) => TaskModel(),
      builder: (BuildContext context, Widget? child) => const TodoApp(),
    ),
  );
}

class TodoApp extends StatelessWidget {
  const TodoApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'My Task List',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple)
            .copyWith(secondary: Colors.deepOrangeAccent),
        useMaterial3: true,
        fontFamily: GoogleFonts.lato().fontFamily, // Apply a global font
        listTileTheme: ListTileThemeData(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        ),
      ),
      home: const TodoScreen(),
      debugShowCheckedModeBanner: false, // Remove the debug banner
    );
  }
}

// --- 4. UI Implementation (StatelessWidget) ---
class TodoScreen extends StatelessWidget {
  const TodoScreen({super.key});

  // A helper function to display a dialog for adding a new task
  void _showAddTaskDialog(BuildContext context) {
    showDialog<void>(
      context: context,
      builder: (BuildContext ctx) {
        return const AddTaskDialog(); // Use the new stateful dialog widget
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: CustomScrollView(
        slivers: <Widget>[
          SliverAppBar(
            expandedHeight: 180.0,
            floating: true,
            pinned: false,
            flexibleSpace: FlexibleSpaceBar(
              background: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: <Color>[
                      Theme.of(context).colorScheme.primary,
                      Theme.of(context).colorScheme.primaryContainer,
                    ],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(24.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.end,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: <Widget>[
                      Text(
                        'My Task List',
                        style: GoogleFonts.lato(
                          fontSize: 34,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Consumer<TaskModel>(
                        builder: (BuildContext context, TaskModel model, Widget? child) {
                          if (model.totalTaskCount == 0) {
                            return const SizedBox.shrink(); // No tasks, hide stats
                          }

                          return Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: <Widget>[
                              Text(
                                '${model.completedTaskCount} of ${model.totalTaskCount} tasks completed',
                                style: GoogleFonts.lato(
                                  fontSize: 16,
                                  color: Colors.white70,
                                ),
                              ),
                              if (model.areAllTasksCompleted)
                                Padding(
                                  padding: const EdgeInsets.only(top: 4.0),
                                  child: Text(
                                    'All tasks completed!',
                                    style: GoogleFonts.lato(
                                      fontSize: 16,
                                      fontWeight: FontWeight.w500,
                                      color: Colors.white,
                                    ),
                                  ),
                                ),
                            ],
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          SliverPadding(
            padding: const EdgeInsets.all(12),
            sliver: Consumer<TaskModel>(
              builder: (BuildContext context, TaskModel model, Widget? child) {
                if (model.tasks.isEmpty) {
                  return SliverFillRemaining(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: <Widget>[
                          Icon(Icons.checklist_rtl, size: 60, color: Colors.grey[400]),
                          const SizedBox(height: 16),
                          Text(
                            'No tasks yet!\nTap the + button to add one.',
                            textAlign: TextAlign.center,
                            style: GoogleFonts.lato(
                              fontSize: 18,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                }
                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (BuildContext context, int index) {
                      final Task task = model.tasks[index];
                      return Dismissible(
                        key: ValueKey<String>(task.id),
                        direction: DismissDirection.endToStart,
                        background: Container(
                          alignment: Alignment.centerRight,
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                          color: Colors.redAccent,
                          child: const Icon(Icons.delete_forever, color: Colors.white, size: 36),
                        ),
                        confirmDismiss: (DismissDirection direction) async {
                          return await showDialog<bool>(
                            context: context,
                            builder: (BuildContext ctx) {
                              return AlertDialog(
                                title: const Text('Confirm Deletion'),
                                content: Text('Are you sure you want to delete "${task.title}"?'),
                                actions: <Widget>[
                                  TextButton(
                                    onPressed: () => Navigator.of(ctx).pop(false),
                                    child: const Text('Cancel'),
                                  ),
                                  ElevatedButton(
                                    style: ElevatedButton.styleFrom(
                                      backgroundColor: Colors.red,
                                      foregroundColor: Colors.white,
                                    ),
                                    onPressed: () => Navigator.of(ctx).pop(true),
                                    child: const Text('Delete'),
                                  ),
                                ],
                              );
                            },
                          );
                        },
                        onDismissed: (DismissDirection direction) {
                          Provider.of<TaskModel>(context, listen: false).removeTask(task.id);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('"${task.title}" dismissed')),
                          );
                        },
                        child: TaskCard(task: task),
                      );
                    },
                    childCount: model.tasks.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddTaskDialog(context),
        tooltip: 'Add New Task',
        backgroundColor: Theme.of(context).colorScheme.secondary,
        foregroundColor: Colors.white,
        child: const Icon(Icons.add),
      ),
    );
  }
}

// New Widget: AddTaskDialog for date/time input
class AddTaskDialog extends StatefulWidget {
  const AddTaskDialog({super.key});

  @override
  State<AddTaskDialog> createState() => _AddTaskDialogState();
}

class _AddTaskDialogState extends State<AddTaskDialog> {
  final TextEditingController _titleController = TextEditingController();
  DateTime? _selectedDate;
  TimeOfDay? _selectedTime;

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime.now().subtract(const Duration(days: 365)), // A year ago
      lastDate: DateTime.now().add(const Duration(days: 365 * 5)), // 5 years from now
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  Future<void> _pickTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _selectedTime ?? TimeOfDay.now(),
    );
    if (picked != null && picked != _selectedTime) {
      setState(() {
        _selectedTime = picked;
      });
    }
  }

  void _addTask() {
    final String title = _titleController.text.trim();
    if (title.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Task title cannot be empty')),
      );
      return;
    }

    DateTime? scheduledDateTime;
    if (_selectedDate != null) {
      scheduledDateTime = DateTime(
        _selectedDate!.year,
        _selectedDate!.month,
        _selectedDate!.day,
        _selectedTime?.hour ?? 0,
        _selectedTime?.minute ?? 0,
      );
    }

    Provider.of<TaskModel>(context, listen: false)
        .addTask(title, scheduledDateTime);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Add New Task'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            TextField(
              controller: _titleController,
              autofocus: true,
              decoration: const InputDecoration(
                hintText: 'e.g., Buy groceries',
                labelText: 'Task Title',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: <Widget>[
                Expanded(
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.calendar_today),
                    label: const Text('Select Date'),
                    onPressed: _pickDate,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.access_time),
                    label: const Text('Select Time'),
                    onPressed: _pickTime,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (_selectedDate != null || _selectedTime != null)
              Container(
                alignment: Alignment.centerLeft,
                padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 4.0),
                decoration: BoxDecoration(
                  color: Colors.grey[50],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.grey[200]!),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    Text(
                      'Scheduled:',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                    if (_selectedDate != null)
                      Text(
                        DateFormat('EEE, MMM d, yyyy').format(_selectedDate!),
                        style: Theme.of(context).textTheme.titleSmall,
                      ),
                    if (_selectedTime != null)
                      Text(
                        _selectedTime!.format(context),
                        style: Theme.of(context).textTheme.titleSmall,
                      ),
                  ],
                ),
              ),
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _addTask,
          child: const Text('Add Task'),
        ),
      ],
    );
  }
}

// New Widget: TaskCard to encapsulate the display of a single task
class TaskCard extends StatelessWidget {
  final Task task;

  const TaskCard({required this.task, super.key});

  @override
  Widget build(BuildContext context) {
    // Determine reminder status for visual cues
    bool isOverdue = false;
    bool isDueSoon = false;
    Color subtitleColor = Colors.grey[700]!;
    IconData timeIcon = Icons.access_time;
    String reminderTextSuffix = '';

    if (!task.isCompleted && task.scheduledTime != null) {
      final DateTime now = DateTime.now();
      final DateTime scheduled = task.scheduledTime!;

      if (scheduled.isBefore(now)) {
        isOverdue = true;
        subtitleColor = Colors.red.shade700;
        timeIcon = Icons.error_outline;
        reminderTextSuffix = ' (Overdue!)';
      } else if (scheduled.difference(now) <= const Duration(minutes: 60)) {
        // Task is due within the next 60 minutes
        isDueSoon = true;
        subtitleColor = Colors.orange.shade700;
        timeIcon = Icons.notification_important_outlined;
        reminderTextSuffix = ' (Due Soon!)';
      }
    }

    return Card(
      elevation: 3,
      margin: const EdgeInsets.symmetric(vertical: 8),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      color: task.isCompleted
          ? Colors.grey[100]
          : (isOverdue
              ? Colors.red.shade50
              : (isDueSoon ? Colors.orange.shade50 : Colors.white)),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: ListTile(
          contentPadding: const EdgeInsets.symmetric(horizontal: 16),
          title: Text(
            task.title,
            style: GoogleFonts.lato(
              fontSize: 17,
              fontWeight: FontWeight.w500,
              decoration: task.isCompleted
                  ? TextDecoration.lineThrough
                  : TextDecoration.none,
              color: task.isCompleted ? Colors.grey[600] : Colors.black87,
            ),
          ),
          subtitle: task.scheduledTime != null
              ? Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: Row(
                    children: <Widget>[
                      Icon(timeIcon, size: 16, color: subtitleColor),
                      const SizedBox(width: 4),
                      Expanded(
                        child: Text(
                          DateFormat('MMM d, hh:mm a').format(task.scheduledTime!) +
                              reminderTextSuffix,
                          style: GoogleFonts.lato(
                            fontSize: 13,
                            color: subtitleColor,
                            decoration: task.isCompleted
                                ? TextDecoration.lineThrough
                                : TextDecoration.none,
                          ),
                          overflow: TextOverflow.ellipsis, // Prevent overflow
                        ),
                      ),
                    ],
                  ),
                )
              : null,
          leading: Checkbox(
            value: task.isCompleted,
            onChanged: (bool? newValue) {
              Provider.of<TaskModel>(context, listen: false)
                  .toggleTaskCompletion(task.id);
            },
            activeColor: Theme.of(context).colorScheme.primary,
            shape: const CircleBorder(),
          ),
          trailing: IconButton(
            icon: const Icon(Icons.delete_outline),
            color: Colors.redAccent,
            onPressed: () {
              // Confirm deletion before removing
              showDialog<bool>(
                context: context,
                builder: (BuildContext ctx) {
                  return AlertDialog(
                    title: const Text('Confirm Deletion'),
                    content: Text('Are you sure you want to delete "${task.title}"?'),
                    actions: <Widget>[
                      TextButton(
                        onPressed: () => Navigator.of(ctx).pop(false),
                        child: const Text('Cancel'),
                      ),
                      ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red,
                          foregroundColor: Colors.white,
                        ),
                        onPressed: () {
                          Provider.of<TaskModel>(context, listen: false).removeTask(task.id);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('"${task.title}" deleted')),
                          );
                          Navigator.of(ctx).pop(true);
                        },
                        child: const Text('Delete'),
                      ),
                    ],
                  );
                },
              );
            },
          ),
        ),
      ),
    );
  }
}
