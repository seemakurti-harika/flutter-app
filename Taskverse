// ignore_for_file: deprecated_member_use

import 'dart:math';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
// 1Ô∏è‚É£ MODEL
class Task {
  final String id;
  final String title;
  bool isCompleted;
  final DateTime? scheduledTime;

  Task({
    required this.id,
    required this.title,
    this.isCompleted = false,
    this.scheduledTime,
  });
}
// 2Ô∏è‚É£ STATE MANAGEMENT
class TaskModel extends ChangeNotifier {
  final List<Task> _tasks = [];

  List<Task> get tasks => _tasks;
  int get completed => _tasks.where((t) => t.isCompleted).length;
  int get total => _tasks.length;

  void addTask(String title, DateTime? time) {
    _tasks.add(Task(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      scheduledTime: time,
    ));
    notifyListeners();
  }

  void toggleTask(String id) {
    final int i = _tasks.indexWhere((t) => t.id == id);
    if (i != -1) {
      _tasks[i].isCompleted = !_tasks[i].isCompleted;
      notifyListeners();
    }
  }

  void removeTask(String id) {
    _tasks.removeWhere((t) => t.id == id);
    notifyListeners();
  }

  void markAllComplete() {
    for (final Task t in _tasks) {
      t.isCompleted = true;
    }
    notifyListeners();
  }

  void clearCompleted() {
    _tasks.removeWhere((t) => t.isCompleted);
    notifyListeners();
  }

  // New method to handle reordering tasks within the model
  void reorderTasks(int oldIndex, int newIndex) {
    // Adjust newIndex if an item is moved to a position after its original index
    if (newIndex > oldIndex) {
      newIndex--;
    }
    final Task task = _tasks.removeAt(oldIndex);
    _tasks.insert(newIndex, task);
    notifyListeners(); // Notify listeners after the internal list has changed
  }
}

class ThemeModel extends ChangeNotifier {
  bool _dark = false;
  bool get dark => _dark;
  ThemeMode get mode => _dark ? ThemeMode.dark : ThemeMode.light;

  void toggle() {
    _dark = !_dark;
    notifyListeners();
  }
}
// 3Ô∏è‚É£ MAIN ENTRY
void main() {
  runApp(
    MultiProvider(
      providers: <ChangeNotifierProvider<ChangeNotifier>>[
        ChangeNotifierProvider<TaskModel>(create: (BuildContext _) => TaskModel()),
        ChangeNotifierProvider<ThemeModel>(create: (BuildContext _) => ThemeModel()),
      ],
      child: const TodoApp(),
    ),
  );
}
// 4Ô∏è‚É£ ROOT APP
class TodoApp extends StatelessWidget {
  const TodoApp({super.key});
  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeModel>(
      builder: (BuildContext context, ThemeModel theme, Widget? child) =>
          MaterialApp(
        debugShowCheckedModeBanner: false,
        title: 'TaskVerse ü§ñ',
        themeMode: theme.mode,
        theme: ThemeData(
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
          useMaterial3: true,
          textTheme: GoogleFonts.poppinsTextTheme(),
        ),
        darkTheme: ThemeData.dark().copyWith(
          textTheme: GoogleFonts.poppinsTextTheme(ThemeData.dark().textTheme),
          colorScheme: ColorScheme.fromSeed(
            seedColor: Colors.deepPurple,
            brightness: Brightness.dark,
          ),
        ),
        home: const TodoScreen(),
      ),
    );
  }
}
// 5Ô∏è‚É£ MAIN SCREEN
class TodoScreen extends StatefulWidget {
  const TodoScreen({super.key});
  @override
  State<TodoScreen> createState() => _TodoScreenState();
}

class _TodoScreenState extends State<TodoScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  String _searchQuery = '';
  String _sortOption = 'None';

  final List<String> quotes = <String>[
    "‚ÄúFocus on being productive, not busy.‚Äù",
    "‚ÄúSmall steps every day lead to big results.‚Äù",
    "‚ÄúAction is the foundational key to all success.‚Äù",
    "‚ÄúYou can do this, one task at a time.‚Äù",
  ];

  @override
  void initState() {
    super.initState();
    _controller =
        AnimationController(vsync: this, duration: const Duration(seconds: 10))
          ..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _addTask(BuildContext context) {
    showDialog<void>(context: context, builder: (BuildContext _) => const AddTaskDialog());
  }

  @override
  Widget build(BuildContext context) {
    final ThemeModel theme = Provider.of<ThemeModel>(context);
    final String quote = quotes[DateTime.now().second % quotes.length];

    return Scaffold(
      body: Stack(
        children: <Widget>[
          // üü£ Animated Background
          AnimatedBuilder(
            animation: _controller,
            builder: (BuildContext context, Widget? child) {
              return CustomPaint(
                painter: NeonBackgroundPainter(
                  progress: _controller.value,
                  dark: theme.dark,
                ),
                child: Container(),
              );
            },
          ),
          // üìã Task content
          CustomScrollView(
            slivers: <Widget>[
              SliverAppBar(
                backgroundColor: Colors.transparent,
                elevation: 0,
                expandedHeight: 180,
                flexibleSpace: FlexibleSpaceBar(
                  background: Padding(
                    padding: const EdgeInsets.all(20),
                    child: Align(
                      alignment: Alignment.bottomLeft,
                      child: Consumer<TaskModel>(
                        builder: (BuildContext context, TaskModel model,
                                Widget? child) =>
                            Column(
                          mainAxisAlignment: MainAxisAlignment.end,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: <Widget>[
                            // Removed "Good [Time of day], Harika üëã" greeting
                            Text(
                              "TaskVerse ü§ñ",
                              style: GoogleFonts.poppins(
                                fontSize: 34,
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                              ),
                            ),
                            Text(
                              quote,
                              style: const TextStyle(
                                  color: Colors.white70, fontSize: 14),
                            ),
                            const SizedBox(height: 6),
                            Text(
                              model.total == 0
                                  ? "Tap + to add a task"
                                  : "${model.completed}/${model.total} tasks done",
                              style: const TextStyle(
                                  color: Colors.white, fontSize: 16),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                actions: <Widget>[
                  IconButton(
                    icon: Icon(
                      theme.dark
                          ? Icons.light_mode_outlined
                          : Icons.dark_mode_outlined,
                      color: Colors.white,
                    ),
                    onPressed: theme.toggle,
                  ),
                  PopupMenuButton<String>(
                    icon: const Icon(Icons.more_vert, color: Colors.white),
                    onSelected: (String value) {
                      final TaskModel taskModel =
                          Provider.of<TaskModel>(context, listen: false);
                      if (value == 'complete') {
                        taskModel.markAllComplete();
                      } else if (value == 'clear') {
                        taskModel.clearCompleted();
                      } else {
                        setState(() => _sortOption = value);
                      }
                    },
                    itemBuilder: (BuildContext _) => const <PopupMenuItem<String>>[
                      PopupMenuItem<String>(
                          value: 'Name', child: Text('Sort by Name')),
                      PopupMenuItem<String>(
                          value: 'Time', child: Text('Sort by Time')),
                      PopupMenuItem<String>(
                          value: 'complete',
                          child: Text('Mark All Completed')),
                      PopupMenuItem<String>(
                          value: 'clear', child: Text('Clear Completed')),
                    ],
                  ),
                ],
              ),

              // üîç Search Bar
              SliverToBoxAdapter(
                child: Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: TextField(
                    decoration: InputDecoration(
                      hintText: 'Search tasks...',
                      prefixIcon: const Icon(Icons.search),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    onChanged: (String value) =>
                        setState(() => _searchQuery = value.toLowerCase()),
                  ),
                ),
              ),

              // üì¶ Task List
              SliverPadding(
                padding: const EdgeInsets.all(16),
                sliver: Consumer<TaskModel>(
                  builder:
                      (BuildContext context, TaskModel model, Widget? child) {
                    List<Task> filtered = model.tasks
                        .where((Task t) =>
                            t.title.toLowerCase().contains(_searchQuery))
                        .toList();

                    if (_sortOption == 'Name') {
                      filtered.sort((Task a, Task b) => a.title.compareTo(b.title));
                    } else if (_sortOption == 'Time') {
                      filtered.sort((Task a, Task b) {
                        if (a.scheduledTime == null) return 1;
                        if (b.scheduledTime == null) return -1;
                        return a.scheduledTime!.compareTo(b.scheduledTime!);
                      });
                    }

                    if (filtered.isEmpty) {
                      return SliverFillRemaining(
                        child: Center(
                          child: Text(
                            '‚ú® No tasks found!',
                            style: GoogleFonts.poppins(
                              color: Colors.white70,
                              fontSize: 18,
                            ),
                          ),
                        ),
                      );
                    }

                    return SliverToBoxAdapter(
                      child: ReorderableListView(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        onReorder: (int oldIndex, int newIndex) {
                          // Delegate the reordering logic to the TaskModel
                          // The model will update its internal list and call notifyListeners,
                          // which will cause the Consumer to rebuild this widget.
                          model.reorderTasks(oldIndex, newIndex);
                        },
                        children: <Widget>[
                          for (final Task t in filtered)
                            Dismissible(
                              key: ValueKey<String>(t.id),
                              background: Container(
                                color: Colors.redAccent,
                                alignment: Alignment.centerLeft,
                                padding: const EdgeInsets.only(left: 20),
                                child: const Icon(Icons.delete,
                                    color: Colors.white),
                              ),
                              secondaryBackground: Container(
                                color: Colors.redAccent,
                                alignment: Alignment.centerRight,
                                padding: const EdgeInsets.only(right: 20),
                                child: const Icon(Icons.delete,
                                    color: Colors.white),
                              ),
                              onDismissed: (DismissDirection _) {
                                final Task removedTask = t;
                                model.removeTask(t.id);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content:
                                        Text('Deleted "${t.title}"'),
                                    action: SnackBarAction(
                                      label: 'UNDO',
                                      onPressed: () {
                                        model.addTask(removedTask.title,
                                            removedTask.scheduledTime);
                                      },
                                    ),
                                  ),
                                );
                              },
                              child: TaskCard(key: ValueKey<String>(t.id), task: t),
                            ),
                        ],
                      ),
                    );
                  },
                ),
              ),
            ],
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: Colors.purpleAccent,
        onPressed: () => _addTask(context),
        child: const Icon(Icons.add, size: 30),
      ),
    );
  }
}
// 6Ô∏è‚É£ TASK CARD
class TaskCard extends StatelessWidget {
  final Task task;
  const TaskCard({required this.task, super.key});

  @override
  Widget build(BuildContext context) {
    bool overdue = false;
    bool soon = false;
    if (task.scheduledTime != null && !task.isCompleted) {
      final Duration diff = task.scheduledTime!.difference(DateTime.now());
      if (diff.isNegative) {
        overdue = true;
      } else if (diff.inMinutes <= 60) {
        soon = true;
      }
    }

    final Color bg = overdue
        ? Colors.red.withOpacity(0.15)
        : soon
            ? Colors.orange.withOpacity(0.15)
            : Colors.white.withOpacity(0.25);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 8),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white24),
        boxShadow: <BoxShadow>[
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
        backgroundBlendMode: BlendMode.overlay,
      ),
      child: ListTile(
        leading: Checkbox(
          shape: const CircleBorder(),
          value: task.isCompleted,
          onChanged: (bool? _) {
            Provider.of<TaskModel>(context, listen: false)
                .toggleTask(task.id);
          },
        ),
        title: Text(
          task.title,
          style: GoogleFonts.poppins(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            decoration: task.isCompleted
                ? TextDecoration.lineThrough
                : TextDecoration.none,
          ),
        ),
        subtitle: task.scheduledTime != null
            ? Text(
                DateFormat('MMM d, hh:mm a').format(task.scheduledTime!) +
                    (overdue
                        ? " (Overdue)"
                        : soon
                            ? " (Soon)"
                            : ""),
                style: TextStyle(
                    color: overdue
                        ? Colors.redAccent
                        : soon
                            ? Colors.orangeAccent
                            : Colors.white70),
              )
            : null,
      ),
    );
  }
}
// 7Ô∏è‚É£ ADD TASK DIALOG
class AddTaskDialog extends StatefulWidget {
  const AddTaskDialog({super.key});
  @override
  State<AddTaskDialog> createState() => _AddTaskDialogState();
}

class _AddTaskDialogState extends State<AddTaskDialog> {
  final TextEditingController _controller = TextEditingController();
  DateTime? _date;
  TimeOfDay? _time;

  void _add() {
    if (_controller.text.trim().isEmpty) return;
    DateTime? schedule;
    if (_date != null) {
      schedule = DateTime(_date!.year, _date!.month, _date!.day,
          _time?.hour ?? 0, _time?.minute ?? 0);
    }
    Provider.of<TaskModel>(context, listen: false)
        .addTask(_controller.text.trim(), schedule);
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Add Task'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          TextField(
            controller: _controller,
            decoration: const InputDecoration(labelText: 'Task name'),
          ),
          const SizedBox(height: 10),
          Row(
            children: <Widget>[
              Expanded(
                child: ElevatedButton.icon(
                  icon: const Icon(Icons.calendar_today),
                  label: const Text('Date'),
                  onPressed: () async {
                    final DateTime? picked = await showDatePicker(
                      context: context,
                      firstDate: DateTime.now(),
                      lastDate: DateTime(2100),
                      initialDate: DateTime.now(),
                    );
                    if (picked != null) setState(() => _date = picked);
                  },
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: ElevatedButton.icon(
                  icon: const Icon(Icons.access_time),
                  label: const Text('Time'),
                  onPressed: () async {
                    final TimeOfDay? t = await showTimePicker(
                        context: context, initialTime: TimeOfDay.now());
                    if (t != null) setState(() => _time = t);
                  },
                ),
              ),
            ],
          ),
        ],
      ),
      actions: <Widget>[
        TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel')),
        ElevatedButton(onPressed: _add, child: const Text('Add')),
      ],
    );
  }
}
// 8Ô∏è‚É£ ANIMATED BACKGROUND PAINTER
class NeonBackgroundPainter extends CustomPainter {
  final double progress;
  final bool dark;
  NeonBackgroundPainter({required this.progress, required this.dark});

  @override
  void paint(Canvas canvas, Size size) {
    final Paint paint = Paint()..blendMode = BlendMode.srcOver;

    final LinearGradient gradient = LinearGradient(
      colors: dark
          ? <Color>[Colors.deepPurple.shade900, Colors.black]
          : <Color>[Colors.purpleAccent, Colors.blueAccent],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    );
    paint.shader =
        gradient.createShader(Rect.fromLTWH(0, 0, size.width, size.height));
    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), paint);

    final Paint orbPaint = Paint()
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 80)
      ..color = dark
          ? Colors.purpleAccent.withOpacity(0.3)
          : Colors.white.withOpacity(0.25);

    for (int i = 0; i < 4; i++) {
      final double dx = size.width * (0.2 + 0.6 * sin(progress * 2 * pi + i));
      final double dy = size.height * (0.3 + 0.5 * cos(progress * 2 * pi + i));
      canvas.drawCircle(Offset(dx, dy), 120, orbPaint);
    }
  }

  @override
  bool shouldRepaint(covariant NeonBackgroundPainter oldDelegate) => true;
}
